/* VERY first anlayzer       */
/* ZH_channel.cxx analizer   */
/* v0 January 2011           */
/* Bortignon Pierluigi       */
/* Vari tentativi di scovare */
/* colour reconnection       */


#include <map>
#include <string>
#include <cmath>
#include <algorithm>
#include <Math/Functions.h>
#include <Math/SVector.h>
#include <Math/SMatrix.h>
#include "TH1F.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TMath.h"
#include "TGraphAsymmErrors.h"
#include "TVector3.h"
#include "time.h"
#include "DataFormats/BTauReco/interface/SecondaryVertexTagInfo.h"

// per il BTag
#include "DataFormats/BTauReco/interface/JetTag.h"

#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ServiceRegistry/interface/Service.h"

#include "DQMServices/Core/interface/DQMStore.h"
#include "DQMServices/Core/interface/MonitorElement.h"

#include "SimTracker/TrackHistory/interface/VertexClassifierByProxy.h"
#include "CommonTools/Statistics/interface/ChiSquaredProbability.h"
#include "DataFormats/Math/interface/Vector.h"
#include "TROOT.h"
#include "Math/VectorUtil.h"
#include <TVector3.h>
#include "TLorentzVector.h"

#include <Math/GenVector/PxPyPzE4D.h>
#include <Math/GenVector/PxPyPzM4D.h>
#include "DataFormats/Math/interface/LorentzVector.h"
#include "TrackingTools/IPTools/interface/IPTools.h"                                    
//#include "DataFormats/Math/interface/deltaR.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/JetReco/interface/PFJetCollection.h"
#include "DataFormats/Candidate/interface/CompositeCandidate.h" 
#include "DataFormats/MuonReco/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/MuonReco/interface/MuonSelectors.h"

#include "DataFormats/PatCandidates/interface/Jet.h"
#include "PhysicsTools/SelectorUtils/interface/JetIDSelectionFunctor.h"
#include "PhysicsTools/SelectorUtils/interface/PFJetIDSelectionFunctor.h"
#include "PhysicsTools/SelectorUtils/interface/Selector.h"

#include "PhysicsTools/SelectorUtils/interface/strbitset.h"

#include "DataFormats/GeometryVector/interface/VectorUtil.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "CommonTools/CandUtils/interface/AddFourMomenta.h" 

#include "CommonTools/UtilAlgos/interface/TFileService.h"
//
// class decleration
//
// using namespace reco;
using namespace std;
using namespace edm;

class ZH_channel : public edm::EDAnalyzer
{
  
public:
  
  explicit ZH_channel(const edm::ParameterSet&);

private:
  
  virtual void analyze(const edm::Event&, const edm::EventSetup&) ;
  virtual void beginJob() ;
  virtual void endJob() ;

  inline int getSign(double ); 
  bool muonJetCleaning( const pat::Jet&, const std::vector<reco::Muon>&, double );
  bool hasHiggsMother( const reco::Candidate* );
  bool hasBdaughters( const reco::Candidate * );
  double getAnglePhiEtaPlane( const pat::Jet* , const pat::Jet* );
  double getAnglePhiEtaPlane( const reco::Candidate* , const reco::Candidate* );
  double getDeltaR( const pat::Jet* , const pat::Jet* );
  double getDeltaR( const reco::Candidate* , const reco::Candidate* );
  double getDeltaR( TLorentzVector , const pat::Jet* );
  double getDeltaR( TVector3 , const pat::Jet* );
  double getDeltaEta( const pat::Jet* , const pat::Jet* );
  double getDeltaEta( const reco::Candidate* , const reco::Candidate* );
  double getDeltaPhi( const pat::Jet*, const pat::Jet* );
  double getPtAsymmetry(const pat::Jet*, const pat::Jet* );
  unsigned int getAssociatedB( std::vector<TLorentzVector> , const pat::Jet* );
  double getBBavProjection( const pat::Jet*, const pat::Jet* );
  TVector2 getTvect( const pat::Jet*, TLorentzVector );
  double getDeltaTheta( const pat::Jet*, const pat::Jet*, TLorentzVector, TLorentzVector );
  double getDeltaX( const pat::Jet*, const pat::Jet*, TLorentzVector, TLorentzVector );
  double getDeltaY( const pat::Jet*, const pat::Jet*, TLorentzVector, TLorentzVector );

  double getMyVar_background( const pat::Jet*, TVector3 );
  double getMyVar_signal( const pat::Jet*, TVector3, double );

  std::vector<double> getPhiRatio( const pat::Jet*, const pat::Jet* );
  std::vector<double> getPhiRatio( const pat::Jet* );

  struct ComparePt {
    bool operator()( const reco::Muon t1, const reco::Muon t2 ) const {
      return t1.p4().pt() > t2.p4().pt();
    }
  };

  ComparePt ptComparator;

  //per creare dei TH1 velocemente InputTag.label
  std::map<std::string,TH1D*> histocontainer_;
  std::map<std::string,TH2D*> histocontainer_2;
  std::map<std::string,TH3D*> histocontainer_3;

  edm::InputTag akt5pfJetsLabel_;
  edm::InputTag muonLabel_;
  edm::InputTag genpLabel_;
  edm::InputTag patJetLabel_;
  edm::ParameterSet pfJetIdSelector_;

  std::vector<int> v_motherId;
  std::vector<int> v_mother_status_background;

  std::vector<const pat::Jet*> v_akt5pfj;

  TLorentzVector TLV_bHadron_general;
  TLorentzVector TLV_bHadron_signal;
  TLorentzVector TLV_bHadron_background;

  std::vector<TLorentzVector> bHadron_general;
  std::vector<TLorentzVector> bHadron_signal;
  std::vector<TLorentzVector> bHadron_background;


  // Member data
  unsigned int goodJetCounter;
  unsigned int badJetCounter;
  unsigned int mypos1;
  unsigned int mypos2;

  Int_t n_event;  
  Int_t myEvents;

  Double_t muonJetCleaningDRcut;
  Double_t JetBassociationCut;
  Double_t higgsMassLowerCut;
  Double_t higgsMassHigherCut;
  Double_t jetDRcut;
  Double_t jetPtAsymmetryHigherCut;

  Double_t higgs_pt;
  Double_t vector_pt;
  Double_t higgsCandidate_pt;
  Double_t jetAnglePhiEtaPlane ;
  Double_t BanglePhiEtaPlane ;
  Double_t deltaR_signal ;
  Double_t invmass_signal ;
  Double_t deltaR_background ;
  Double_t invmass_background ;
  Double_t alphaAngle ;
  Double_t betaDistance ;
  Double_t deltaR_general ;
  Double_t invmass_general ;
  Double_t BdeltaEta;
  Double_t JetDeltaEta;
  Double_t JetDeltaEtaSmart;
  Double_t epsilonDeltaEta;
  Double_t gammaDeltaR;
  Double_t BdeltaR;
  Double_t JetDeltaR;

  Double_t jetDeltaPhi;
  Double_t jetPtAsymmetry;

  Double_t myVar_background;
  Double_t myVar_signal;

  bool bHadron;  

};

ZH_channel::ZH_channel(const edm::ParameterSet& iConfig) : 

  histocontainer_(),
  histocontainer_2(),
  histocontainer_3(),

  //cleaning cut
  jetDRcut(iConfig.getUntrackedParameter<double>("jetDeltaRcut")),
  muonJetCleaningDRcut(iConfig.getUntrackedParameter<double>("muonJetCleaningDRcut_")),
  JetBassociationCut(iConfig.getUntrackedParameter<double>("JetBassociationDRCut")),
  higgsMassLowerCut(iConfig.getUntrackedParameter<double>("hMassLowerCut")),
  higgsMassHigherCut(iConfig.getUntrackedParameter<double>("hMassHigherCut")),
  jetPtAsymmetryHigherCut(iConfig.getUntrackedParameter<double>("jetPtAsymmetryHigherCut")),

  //edm collection
  genpLabel_(iConfig.getUntrackedParameter<edm::InputTag>("genPart")),
  muonLabel_(iConfig.getUntrackedParameter<edm::InputTag>("muonCand")),
  akt5pfJetsLabel_(iConfig.getUntrackedParameter<edm::InputTag>("akt5pfJets")),
  patJetLabel_(iConfig.getUntrackedParameter<edm::InputTag>("patJets")),
  pfJetIdSelector_(iConfig.getParameter<edm::ParameterSet>("pfJetIDSelector") )
{

  //Initialize counters
  n_event = 0;
  myEvents = 0;

}   

void ZH_channel::analyze(const edm::Event& iEvent, const edm::EventSetup& setup)
{
  ++n_event;

  //initialising each events
  higgs_pt = 0;
  vector_pt = 0;

  std::cout << "*** Analyzing " << iEvent.id() << " n_event = " << n_event << std::endl << std::endl;


  // Get b tag information
  edm::Handle<reco::JetTagCollection> bTagHandle;
  //  iEvent.getByLabel("trackCountingHighEffBJetTags", bTagHandle);
  iEvent.getByLabel("simpleSecondaryVertexHighPurBJetTags", bTagHandle);
  const reco::JetTagCollection & bTags = *(bTagHandle.product());


  //patJet
  edm::Handle< pat::JetCollection > patJetHandle;
  iEvent.getByLabel(patJetLabel_, patJetHandle);
  const  pat::JetCollection &patJet = *patJetHandle.product();
  //JetID. Siggested cuts for 7TeV analysis: LOOSE. https://twiki.cern.ch/twiki/bin/viewauth/CMS/JetID 
  //  JetIDSelectionFunctor jetIDFunctor( JetIDSelectionFunctor::PURE09, JetIDSelectionFunctor::LOOSE );
  PFJetIDSelectionFunctor pfJetIDFunctor( pfJetIdSelector_ );

  //pfJet
//   edm::Handle<reco::PFJetCollection> recoAKT5PFJets;
//   iEvent.getByLabel(akt5pfJetsLabel_, recoAKT5PFJets);
//   const reco::PFJetCollection &akt5pfj = *recoAKT5PFJets.product();

  //muon handle
  //  edm::Handle< edm::View< reco::Muon > > muonHandle;
  edm::Handle< reco::MuonCollection > muonHandle;
  iEvent.getByLabel(muonLabel_,muonHandle);
  //  edm::View<reco::Muon> muons = *muonHandle;
  const reco::MuonCollection &UnsortedMuons = *muonHandle.product(); 
  reco::MuonCollection muons = UnsortedMuons;
  std::sort( muons.begin(), muons.end(), ptComparator);


  // Generated particles handle
  edm::Handle<reco::GenParticleCollection> genP;
  iEvent.getByLabel(genpLabel_,genP);
  //edm::View<reco::GenParticle> genParticles = *genP;
  const reco::GenParticleCollection &genParticles = *genP.product();

  v_motherId.clear();
  v_mother_status_background.clear();
  bHadron_general.clear();
  bHadron_signal.clear();
  bHadron_background.clear();
  v_akt5pfj.clear();

  double deltaPhi = false;
  std::vector<const reco::Candidate*> v_muon;
  std::vector<const reco::Candidate*> v_muon_p;
  std::vector<const reco::Candidate*> v_muon_n;
  const pat::Jet *leadingJet;
  const pat::Jet *secondLeadingJet;
  reco::CandidateCollection BhadronCollection;
  reco::CandidateCollection BhadronCollectionSignal;
  reco::CandidateCollection BhadronCollectionBackground;

  // needed for the jetId
  pat::strbitset ret = pfJetIDFunctor.getBitTemplate();

  // count the good jets
  goodJetCounter = 0;
  badJetCounter = 0;

  // The jets are pt ordered
  for(size_t jetIdx = 0; jetIdx < patJet.size(); ++jetIdx){
    if( patJet.at(jetIdx).isPFJet() == true 
 	and pfJetIDFunctor( patJet.at(jetIdx), ret ) == true 
	and muonJetCleaning( patJet.at(jetIdx), muons, muonJetCleaningDRcut ) == false ){
      goodJetCounter++;
      v_akt5pfj.push_back( new pat::Jet (patJet.at(jetIdx).correctedJet("abs")) );
//       v_akt5pfj.push_back( &(akt5pfj.at(jetIdx)) );
//       std::cout << "Good jet N cost = " << patJet.at(jetIdx).chargedMultiplicity() 
//      + patJet.at(jetIdx).neutralMultiplicity() << std::endl;
//       std::cout << "Good jet pt = " << patJet.at(jetIdx).p4().Pt() << std::endl;
      histocontainer_["h_goodJetEta"]->Fill( patJet.at(jetIdx).p4().Eta() );
      histocontainer_["h_goodJetPt"]->Fill( patJet.at(jetIdx).p4().Pt() );
	}
    else{
      badJetCounter++;
//       std::cout << "Bad jet N cost = " << patJet.at(jetIdx).chargedMultiplicity() 
//       + patJet.at(jetIdx).neutralMultiplicity() << std::endl;
//       std::cout << "Bad jet pt = " << patJet.at(jetIdx).p4().Pt() << std::endl;
      histocontainer_["h_badJetPt"]->Fill( patJet.at(jetIdx).p4().Pt() );
      histocontainer_["h_badJetEta"]->Fill( patJet.at(jetIdx).p4().Eta() );
	}
  }

  for( size_t muon_iter = 0; muon_iter < muons.size(); muon_iter++){
    if( muon::isGoodMuon( muons.at(muon_iter), muon::GlobalMuonPromptTight) ){
      if( muons.at(muon_iter).charge() == 1 )
	v_muon_p.push_back( &( muons.at(muon_iter) ) );
      else
	v_muon_n.push_back( &( muons.at(muon_iter) ) );
    } 
  }

  //Event selection: at least two jets and two muons with opposite sign
  if( v_akt5pfj.size() < 2
      or v_muon_n.size() < 1
      or v_muon_p.size() < 1 )
    return void();

  // Questo e' pericoloso se si vuole trovare il color flow tra i due b... forse e' il caso di toglierlo
  //no additional akt5pfjets with pt > 20 GeV
  if( v_akt5pfj.size() > 2
      and v_akt5pfj.at(2)->p4().pt() > 20 )
    return void();

  v_muon.push_back( v_muon_p.at(0) );
  v_muon.push_back( v_muon_n.at(0) );  

  leadingJet = v_akt5pfj.at(0);
  secondLeadingJet = v_akt5pfj.at(1);
  reco::CompositeCandidate higgsCandidate;
  higgsCandidate.addDaughter( *v_akt5pfj.at(0) );
  higgsCandidate.addDaughter( *v_akt5pfj.at(1) );
  AddFourMomenta addp4;
  addp4.set(higgsCandidate);
  higgsCandidate_pt = higgsCandidate.p4().Pt();
  
  reco::CompositeCandidate Zcandidate;
  Zcandidate.addDaughter( *v_muon.at(0) );
  Zcandidate.addDaughter( *v_muon.at(1) );
  AddFourMomenta addZp4;
  addZp4.set(Zcandidate);
  double Zcandidate_pt = Zcandidate.p4().Pt();
  double ZH_deltaPhi = Geom::deltaPhi(higgsCandidate.p4(), Zcandidate.p4());

//   histocontainer_["h_higgsCandidate_pt"]->Fill( higgsCandidate_pt );
//   histocontainer_["h_higgsCandidate_mass"]->Fill( higgsCandidate.p4().M() );
//   histocontainer_["h_Zcandidate_pt"]->Fill( Zcandidate_pt );
//   histocontainer_["h_Zcandidate_mass"]->Fill( Zcandidate.p4().M() );
//   histocontainer_["h_HZ_deltaPhi"]->Fill( ZH_deltaPhi );

// Event selection
  if( Zcandidate_pt < 155
      or TMath::Abs(ZH_deltaPhi) < 2.75
      or Zcandidate.p4().M() < 75
      or Zcandidate.p4().M() > 105 )
    return void();

  histocontainer_["h_higgsCandidate_pt"]->Fill( higgsCandidate_pt );
  histocontainer_["h_higgsCandidate_mass"]->Fill( higgsCandidate.p4().M() );
  histocontainer_["h_Zcandidate_pt"]->Fill( Zcandidate_pt );
  histocontainer_["h_Zcandidate_mass"]->Fill( Zcandidate.p4().M() );
  histocontainer_["h_HZ_deltaPhi"]->Fill( ZH_deltaPhi );
  

  // taglio sulla finestra di massa dell'higgs
  if( higgsCandidate.p4().M() < higgsMassLowerCut or
      higgsCandidate.p4().M() > higgsMassHigherCut )
    return void();
  

  // REAL BTAG
  // Loop over jets and study b tag info.
  // max > 0.9
  // min > 0.44
  bool maxBTag = false;
  bool minBTag = false;
  for (unsigned int i = 0; i != bTags.size(); ++i) {
//     std::cout<<" Jet "<< i 
// 	     <<" has b tag discriminator = "<<bTags[i].second
// 	     << " and jet Pt = "<<bTags[i].first->pt()<< std::endl;
    if( bTags[i].first->pt() == leadingJet->p4().Pt() )
      if(bTags[i].second > 0.9)
	maxBTag = true;
    if( bTags[i].first->pt() == secondLeadingJet->p4().Pt() )
      if(bTags[i].second > 0.44)
	minBTag = false;
  }



  // MC TRUTH BTAGGING
  // Generated particles loop
  for( reco::GenParticleCollection::const_iterator iGenp = genParticles.begin(); 
       iGenp != genParticles.end();
       ++iGenp) 
    {

      const reco::Candidate *genCandidate = &(*iGenp);

      if( fabs(iGenp->eta()) > 2.5
	  or iGenp->pt() < 1 )
	continue;
      
      HepPDT::ParticleID particleID( iGenp->pdgId() );

      if( iGenp->numberOfDaughters() ){
	std::vector<HepPDT::ParticleID> daughterID;
	for( reco::Candidate::const_iterator iDau = iGenp->begin();
	     iDau != iGenp->end();
	     ++iDau )
	  daughterID.push_back( iDau->pdgId() );
      }
      
      histocontainer_["h_pdgId"]->Fill(iGenp->pdgId());
      histocontainer_2["h2_pdgId_status"]->Fill(iGenp->pdgId(), iGenp->status());
      histocontainer_2["h2_pdgId_particleID"]->Fill(iGenp->pdgId(), particleID.pid());
      
//       // pt of the bosons
//       // 24 e la W+ mentre 23 e la Z. h e 25 
//       if( abs(particleID.pid()) == 23 and iGenp->status() == 3 ){
// 	const reco::Candidate &ZCandidate = *iGenp;
// 	if( Geom::deltaPhi(higgsCandidate.p4(), ZCandidate.p4()) < 2.75 )
// 	  deltaPhi = true;
// 	histocontainer_["h_HZ_deltaPhi"]->Fill( Geom::deltaPhi(higgsCandidate.p4(), ZCandidate.p4()) );
// 	vector_pt = iGenp->pt();
// 	histocontainer_["h_Z_pt"]->Fill(iGenp->pt());
//       }
//       if( abs(particleID.pid()) == 24 and iGenp->status() == 3 ){
// 	vector_pt = iGenp->pt();
// 	histocontainer_["h_W_pt"]->Fill(iGenp->pt());
//       }
//       if( particleID.pid() == 25 
// 	  and ( abs(iGenp->mother()->pdgId()) == 24
// 		or abs(iGenp->mother()->pdgId()) == 23 ) ){
// 	higgs_pt = iGenp->pt();
// 	histocontainer_["h_H_pt"]->Fill(iGenp->pt());
//       }
      
      // saltiamo tutto quello che non e B hadron stabile
      if( not particleID.hasBottom() 
	  or  not ( particleID.isMeson()
		    or particleID.isBaryon() )
	  or hasBdaughters( genCandidate )
	  )
	continue;

      BhadronCollection.push_back( std::auto_ptr<reco::GenParticle>(  new reco::GenParticle (*iGenp) ) );

      TLV_bHadron_general.SetPtEtaPhiE( iGenp->pt(), iGenp->eta(), iGenp->phi(), iGenp->energy() );
      bHadron_general.push_back( TLV_bHadron_general );
      
      if( iGenp->numberOfMothers() ){
	HepPDT::ParticleID motherID( iGenp->mother()->pdgId() );
	// Higgs. signal
	if( hasHiggsMother( genCandidate ) ){
	  BhadronCollectionSignal.push_back( std::auto_ptr<reco::GenParticle>(  new reco::GenParticle (*iGenp) ) );
	  TLV_bHadron_signal.SetPtEtaPhiE( iGenp->pt(), iGenp->eta(), iGenp->phi(), iGenp->energy() );
	  bHadron_signal.push_back( TLV_bHadron_signal );
	}
	// Background
	else {
	  BhadronCollectionBackground.push_back( std::auto_ptr<reco::GenParticle>(  new reco::GenParticle (*iGenp) ) );
	  v_mother_status_background.push_back(iGenp->mother()->status());
	  TLV_bHadron_background.SetPtEtaPhiE( iGenp->pt(), iGenp->eta(), iGenp->phi(), iGenp->energy() );
	  bHadron_background.push_back( TLV_bHadron_background );
	  v_motherId.push_back(motherID.pid());
	}
      }
    }//END GENPARTICLEs LOOP
  
  mypos1 = 1e2;
  mypos2 = 1e2;

  // store infos
  //all the B hadrons couples
  if( bHadron_general.size() > 1 ){
    myEvents++;

    // JET PT ASYMMETRY
    jetPtAsymmetry = getPtAsymmetry( leadingJet, secondLeadingJet );
    if( jetPtAsymmetry > jetPtAsymmetryHigherCut )
      return void();

    //jet-B_hadron association and cut
    mypos1 = getAssociatedB( bHadron_general, leadingJet );
    mypos2 = getAssociatedB( bHadron_general, secondLeadingJet );
    if( getDeltaR( bHadron_general.at(mypos1), leadingJet ) > JetBassociationCut or
	getDeltaR( bHadron_general.at(mypos2), secondLeadingJet ) > JetBassociationCut )
      return void();

    // jet-B_hadron pairs
    std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair1 ( bHadron_general.at(mypos1), *leadingJet );
    std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair2 ( bHadron_general.at(mypos2), *secondLeadingJet );

    TLorentzVector tlvjet1, tlvjet2;
    tlvjet1.SetPtEtaPhiE(bVertex_Jets_pair1.second.p4().Pt(), bVertex_Jets_pair1.second.p4().Eta(), bVertex_Jets_pair1.second.p4().Phi(), bVertex_Jets_pair1.second.p4().E() );
    tlvjet2.SetPtEtaPhiE(bVertex_Jets_pair2.second.p4().Pt(), bVertex_Jets_pair2.second.p4().Eta(), bVertex_Jets_pair2.second.p4().Phi(), bVertex_Jets_pair2.second.p4().E() );

    // secondLeadingB - leadingB
    TVector3 BBdir1 = bVertex_Jets_pair2.first.Vect() - bVertex_Jets_pair1.first.Vect();
    //leadingB - secondLeadingB
    TVector3 BBdir2 = bVertex_Jets_pair1.first.Vect() - bVertex_Jets_pair2.first.Vect();

    // jets radiation 4momenta (jet - b)
    TLorentzVector radiation1 = tlvjet1 - bVertex_Jets_pair1.first;
    TLorentzVector radiation2 = tlvjet2 - bVertex_Jets_pair2.first;
    TVector3 v_radiation1BBOrtProjection = radiation1.Vect().Cross(BBdir1.Unit());
    TVector3 v_radiation2BBOrtProjection = radiation1.Vect().Cross(BBdir2.Unit());
    double radiation1BBOrtProjection = v_radiation1BBOrtProjection.Mag();
    double radiation2BBOrtProjection = v_radiation2BBOrtProjection.Mag();
    double radiation1BBProjection = radiation1.Vect().Dot(BBdir1.Unit());
    double radiation2BBProjection = radiation2.Vect().Dot(BBdir2.Unit());
    double radiation1Energy = radiation1.E();
    double radiation2Energy = radiation2.E();
    
    // queste sono le variabile che usa l'articolo teorico sulla color reconnection
    double leadingDeltaTheta = getDeltaTheta( leadingJet , secondLeadingJet, bVertex_Jets_pair1.first, bVertex_Jets_pair2.first );
    double secondLeadingDeltaTheta = getDeltaTheta( secondLeadingJet, leadingJet, bVertex_Jets_pair2.first, bVertex_Jets_pair1.first );
    double leadingDeltaX = getDeltaX( leadingJet , secondLeadingJet, bVertex_Jets_pair1.first, bVertex_Jets_pair2.first );
    double secondLeadingDeltaX = getDeltaX( secondLeadingJet, leadingJet, bVertex_Jets_pair2.first, bVertex_Jets_pair1.first );
    double leadingDeltaY = getDeltaY( leadingJet , secondLeadingJet, bVertex_Jets_pair1.first, bVertex_Jets_pair2.first );
    double secondLeadingDeltaY = getDeltaY( secondLeadingJet, leadingJet, bVertex_Jets_pair2.first, bVertex_Jets_pair1.first );

    histocontainer_2["h2_deltaX_deltaY"]->Fill(leadingDeltaX, leadingDeltaY);
    histocontainer_2["h2_deltaX_deltaY"]->Fill(secondLeadingDeltaX, secondLeadingDeltaY);

    jetAnglePhiEtaPlane =  getAnglePhiEtaPlane( leadingJet, secondLeadingJet );
    BanglePhiEtaPlane = getAnglePhiEtaPlane( &(BhadronCollection[0]) , &(BhadronCollection[1]) );
    std::vector<double> jetDistancePerpendicularLineGeneral;
    jetDistancePerpendicularLineGeneral.push_back( TMath::Abs( leadingJet->p4().Phi() - leadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) ) ;
    jetDistancePerpendicularLineGeneral.push_back( TMath::Abs( secondLeadingJet->p4().Phi() - secondLeadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) );
    alphaAngle = TMath::Abs( jetAnglePhiEtaPlane - BanglePhiEtaPlane ) ;
    if ( alphaAngle > 0.5*TMath::Pi() )
      alphaAngle = TMath::Abs( TMath::Abs( alphaAngle ) - TMath::Pi() ); // it takes the inclusive angle
    BdeltaR = getDeltaR( &(BhadronCollection[0]), &(BhadronCollection[1]) );
    JetDeltaR = getDeltaR( leadingJet, secondLeadingJet );
    if(JetDeltaR > jetDRcut )
      return void();

    betaDistance = BdeltaR - JetDeltaR;
    BdeltaEta = TMath::Abs( getDeltaEta( &(BhadronCollection[0]), &(BhadronCollection[1]) ) );
    JetDeltaEta = TMath::Abs( getDeltaEta( leadingJet, secondLeadingJet ) );
    jetDeltaPhi = getDeltaPhi( leadingJet, secondLeadingJet );
    epsilonDeltaEta = BdeltaEta - JetDeltaEta;
    deltaR_general =  bHadron_general.at(0).DeltaR( bHadron_general.at(1) );
    TLorentzVector p4sum = bHadron_general.at(0) + bHadron_general.at(1);
    invmass_general = p4sum.M();
    TVector3 tmp1TV3, tmp2TV3;
    tmp1TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
    tmp2TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
    gammaDeltaR = 0.5 * ( p4sum.Vect().DeltaR( tmp1TV3 ) + p4sum.Vect().DeltaR( tmp2TV3 ) ) ;
    std::vector<double> ptb_general;
    ptb_general.push_back( bHadron_general.at(0).Pt() );
    ptb_general.push_back( bHadron_general.at(1).Pt() );
    std::sort(ptb_general.begin(), ptb_general.end());
    double deltaEta1General = TMath::Abs( bVertex_Jets_pair1.first.Eta() - bVertex_Jets_pair1.second.p4().Eta() ) ;
    double deltaEta2General = TMath::Abs( bVertex_Jets_pair2.first.Eta() - bVertex_Jets_pair2.second.p4().Eta() ) ;
    double deltaEta1SmartGeneral;
    double deltaEta2SmartGeneral;

    // if the jets have opposite eta signs
    if( getSign(leadingJet->p4().Eta()*secondLeadingJet->p4().Eta()) == -1 ){
      JetDeltaEtaSmart = TMath::Abs( getDeltaEta( leadingJet, secondLeadingJet ) );
      histocontainer_["h_jetDeltaEtaSmartGeneral"]->Fill(JetDeltaEtaSmart);
      histocontainer_["h_epsilonDeltaEtaSmartGeneral"]->Fill( 0.5 * ( bVertex_Jets_pair1.first.Eta() - bVertex_Jets_pair1.second.p4().Eta() ) * getSign( bVertex_Jets_pair1.second.p4().Eta() ) + 
							      ( bVertex_Jets_pair2.first.Eta() - bVertex_Jets_pair2.second.p4().Eta() ) * getSign( bVertex_Jets_pair2.second.p4().Eta() ) );
    }
    else{
      // plot only the one closer to the beam pipe
      if( TMath::Abs( leadingJet->p4().Eta() ) - TMath::Abs( secondLeadingJet->p4().Eta() ) > 0 )
	histocontainer_["h_epsilonDeltaEtaSmartGeneral"]->Fill( deltaEta1SmartGeneral = ( bVertex_Jets_pair1.first.Eta() - bVertex_Jets_pair1.second.p4().Eta() ) * getSign( bVertex_Jets_pair1.second.p4().Eta() ) );
      else
	histocontainer_["h_epsilonDeltaEtaSmartGeneral"]->Fill( deltaEta2SmartGeneral = ( bVertex_Jets_pair2.first.Eta() - bVertex_Jets_pair2.second.p4().Eta() ) *  getSign( bVertex_Jets_pair1.second.p4().Eta() ) );
    }

    // TRACK PROJECTION IN BB AXIS
    reco::TrackRefVector patLeadingJetTrack;
    reco::TrackRefVector patSecondLeadingJetTrack;
    TVector3 t_vect;
    double trackBBProjection;
    //loop su tutte le tracce del leading jet
    patLeadingJetTrack = leadingJet->associatedTracks();
    for(size_t idx = 0; idx < patLeadingJetTrack.size(); idx++){
      t_vect.SetXYZ(patLeadingJetTrack.at(idx)->px(),patLeadingJetTrack.at(idx)->py(),patLeadingJetTrack.at(idx)->pz());
      trackBBProjection = t_vect.Dot(BBdir1.Unit());
      histocontainer_["h_trackBBProjection"]->Fill(trackBBProjection);
      histocontainer_["h_trackBBPercentProjection"]->Fill(trackBBProjection/patLeadingJetTrack.at(idx)->p());
    }
    //loop su tutte le tracce del secondLeading jet
    patSecondLeadingJetTrack = secondLeadingJet->associatedTracks();
    for(size_t idx = 0; idx < patSecondLeadingJetTrack.size(); idx++){
      t_vect.SetXYZ(patSecondLeadingJetTrack.at(idx)->px(),patSecondLeadingJetTrack.at(idx)->py(),patSecondLeadingJetTrack.at(idx)->pz());
      trackBBProjection = t_vect.Dot(BBdir2.Unit());
      histocontainer_["h_trackBBProjection"]->Fill(trackBBProjection);
      histocontainer_["h_trackBBPercentProjection"]->Fill(trackBBProjection/patSecondLeadingJetTrack.at(idx)->p());
    }


    // PFCANDIDATE PROJECTION IN BB AXIS
    std::vector<reco::PFCandidatePtr> patLeadingJetPFCandidate;
    std::vector<reco::PFCandidatePtr> patSecondLeadingJetPFCandidate;
    TVector3 pfc_vect;
    TVector3 pfCandidateBBOrtProjection;
    double  totalpfcBBProjection = 0;
    double  totalpfcBBOrtProjection = 0;
    double pfCandidateBBProjection = 1e10;
    double pfCandidateBBOrtProjectionSum = 0;
    double pfCandidateBBProjectionSum = 0;

    double lepVar = 1e10;
    std::vector<double> evLepVarR1;
    std::vector<double> evLepVarR2;

    // if the jets have opposite eta signs draw both
    if( getSign(leadingJet->p4().Eta()*secondLeadingJet->p4().Eta()) == -1 ){

      // REGION 1 (between leadingJet and secondLeadingJet)
      std::vector<double> phiRegion1 = getPhiRatio(leadingJet, secondLeadingJet);
      // REGION 2 (between leadingJet and its closest beamline)
      std::vector<double> phiRegion2 = getPhiRatio(leadingJet);
      // REGION 3 (between secondLeadingJet and its closest beamline)
      std::vector<double> phiRegion3 = getPhiRatio(secondLeadingJet);

      totalpfcBBProjection = 0;
      totalpfcBBOrtProjection = 0;
      pfCandidateBBProjection = 1e10;
      pfCandidateBBOrtProjectionSum = 0;
      pfCandidateBBProjectionSum = 0;
      //loop su tutti pf candidate del leading jet
      patLeadingJetPFCandidate = leadingJet->getPFConstituents();
      for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir1.Unit());
	pfCandidateBBProjection = pfc_vect.Dot(BBdir1.Unit());
	totalpfcBBProjection += TMath::Abs(pfCandidateBBProjection);
	totalpfcBBOrtProjection += pfCandidateBBOrtProjection.Mag();
      }
      for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir1.Unit());
	pfCandidateBBProjection = pfc_vect.Dot(BBdir1.Unit());
	pfCandidateBBOrtProjectionSum += (pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection); 
	pfCandidateBBProjectionSum += (pfCandidateBBProjection/totalpfcBBProjection); 
	// LEP var region 1
	if( ( pfc_vect.Eta() < leadingJet->p4().Eta() and 
	      pfc_vect.Eta() > secondLeadingJet->p4().Eta() ) or 
	    ( pfc_vect.Eta() < secondLeadingJet->p4().Eta() and 
	      pfc_vect.Eta() > leadingJet->p4().Eta() ) ) {
	  lepVar = TMath::Abs(pfc_vect.Eta()-leadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	  evLepVarR1.push_back(lepVar);
	  histocontainer_["h_lepVarRegion1"]->Fill(lepVar);
	}
	// LEP var region 2 (between the beamline and the jet)
	if( TMath::Abs(pfc_vect.Eta()) > TMath::Abs(leadingJet->p4().Eta()) ){
	  lepVar = TMath::Abs(pfc_vect.Eta()-leadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	  evLepVarR2.push_back(lepVar);
	  histocontainer_["h_lepVarRegion2"]->Fill(lepVar);
	}
	histocontainer_["h_pfCandidateBBOrtProjection"]->Fill(pfCandidateBBOrtProjection.Mag());
	histocontainer_["h_pfCandidateBBProjection"]->Fill(pfCandidateBBProjection);
	histocontainer_["h_pfCandidateBBOrtPercentProjection"]->Fill(pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection);
	histocontainer_["h_pfCandidateBBPercentProjection"]->Fill(pfCandidateBBProjection/totalpfcBBProjection);
	histocontainer_["h_pfCandidateDRjet"]->Fill( getDeltaR( pfc_vect, leadingJet) );
	histocontainer_["h_nOfpfcLeadingJet"]->Fill(patLeadingJetPFCandidate.size());
      }
      histocontainer_["h_pfCandidateBBProjectionSum"]->Fill(pfCandidateBBProjectionSum);
      histocontainer_["h_pfCandidateBBOrtProjectionSum"]->Fill(pfCandidateBBOrtProjectionSum);
      pfCandidateBBOrtProjectionSum = 0;
      pfCandidateBBProjectionSum = 0;
      totalpfcBBOrtProjection = 0;
      totalpfcBBProjection = 0;
      for(size_t idx = 0; idx < patSecondLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patSecondLeadingJetPFCandidate.at(idx)->px(),patSecondLeadingJetPFCandidate.at(idx)->py(),patSecondLeadingJetPFCandidate.at(idx)->pz());
	pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir2.Unit());
	pfCandidateBBProjection = pfc_vect.Dot(BBdir2.Unit());
	totalpfcBBProjection += TMath::Abs(pfCandidateBBProjection);
	totalpfcBBOrtProjection += pfCandidateBBOrtProjection.Mag();
      } 
      //loop su tutti i pf candidate del secondLeading jet
      patSecondLeadingJetPFCandidate = secondLeadingJet->getPFConstituents();
      for(size_t idx = 0; idx < patSecondLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patSecondLeadingJetPFCandidate.at(idx)->px(),patSecondLeadingJetPFCandidate.at(idx)->py(),patSecondLeadingJetPFCandidate.at(idx)->pz());
	pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir2.Unit());
	pfCandidateBBProjection = pfc_vect.Dot(BBdir2.Unit());
	pfCandidateBBOrtProjectionSum += pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection; 
	pfCandidateBBProjectionSum += pfCandidateBBProjection/totalpfcBBProjection; 
	// LEP var region 1
	if( ( pfc_vect.Eta() < leadingJet->p4().Eta() and 
	      pfc_vect.Eta() > secondLeadingJet->p4().Eta() ) or 
	    ( pfc_vect.Eta() < secondLeadingJet->p4().Eta() and 
	      pfc_vect.Eta() > leadingJet->p4().Eta() ) ){
	  lepVar = TMath::Abs(pfc_vect.Eta()-secondLeadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	  evLepVarR1.push_back(lepVar);
	  histocontainer_["h_lepVarRegion1"]->Fill(lepVar);
	}
	// LEP var region 2 (between the beamline and the jet)
	if( TMath::Abs(pfc_vect.Eta()) > TMath::Abs(secondLeadingJet->p4().Eta()) ){
	  lepVar = TMath::Abs(pfc_vect.Eta()-secondLeadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	  evLepVarR2.push_back(lepVar);
	  histocontainer_["h_lepVarRegion2"]->Fill(lepVar);
	}
	histocontainer_["h_pfCandidateBBOrtProjection"]->Fill(pfCandidateBBOrtProjection.Mag());
	histocontainer_["h_pfCandidateBBProjection"]->Fill(pfCandidateBBProjection);
	histocontainer_["h_pfCandidateBBOrtPercentProjection"]->Fill(pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection);
	histocontainer_["h_pfCandidateBBPercentProjection"]->Fill(pfCandidateBBProjection/totalpfcBBProjection);
	histocontainer_["h_pfCandidateDRjet"]->Fill( getDeltaR( pfc_vect, secondLeadingJet) );
	histocontainer_["h_nOfpfcSecondLeadingJet"]->Fill(patSecondLeadingJetPFCandidate.size());
      }
      histocontainer_["h_pfCandidateBBOrtProjectionSum"]->Fill(pfCandidateBBOrtProjectionSum);
      histocontainer_["h_pfCandidateBBProjectionSum"]->Fill(pfCandidateBBProjectionSum);
      
    }
    else{
      // plot only the one closer to the beam pipe
      if( TMath::Abs( leadingJet->p4().Eta() ) - TMath::Abs( secondLeadingJet->p4().Eta() ) > 0 ){

	// REGION 1 (between leadingJet and secondLeadingJet)
	std::vector<double> phiRegion1 = getPhiRatio(leadingJet, secondLeadingJet);
	// REGION 2 (between leadingJet and its closest beamline)
	std::vector<double> phiRegion2 = getPhiRatio(leadingJet);
	
	totalpfcBBProjection =  0;
	totalpfcBBOrtProjection = 0;
	pfCandidateBBProjection = 1e10;
	pfCandidateBBOrtProjectionSum = 0;
	pfCandidateBBProjectionSum = 0;
	//loop su tutti pf candidate del leading jet
	patLeadingJetPFCandidate = leadingJet->getPFConstituents();
	for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	  pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	  pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir1.Unit());
	  pfCandidateBBProjection = pfc_vect.Dot(BBdir1.Unit());
	  totalpfcBBProjection += TMath::Abs(pfCandidateBBProjection);
	  totalpfcBBOrtProjection += pfCandidateBBOrtProjection.Mag();
	}
	for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	  pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	  pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir1.Unit());
	  pfCandidateBBProjection = pfc_vect.Dot(BBdir1.Unit());
	  pfCandidateBBOrtProjectionSum += pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection; 
	  pfCandidateBBProjectionSum += pfCandidateBBProjection/totalpfcBBProjection; 
	  // LEP var region 1
	  if( ( pfc_vect.Eta() < leadingJet->p4().Eta() and 
		pfc_vect.Eta() > secondLeadingJet->p4().Eta() ) or 
	      ( pfc_vect.Eta() < secondLeadingJet->p4().Eta() and 
		pfc_vect.Eta() > leadingJet->p4().Eta() ) ){
	    lepVar = TMath::Abs(pfc_vect.Eta()-leadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	    evLepVarR1.push_back(lepVar);
	    histocontainer_["h_lepVarRegion1"]->Fill(lepVar);
	  }
	  // LEP var region 2 (between the beamline and the jet)
	  if( TMath::Abs(pfc_vect.Eta()) > TMath::Abs(leadingJet->p4().Eta()) ){
	    lepVar = TMath::Abs(pfc_vect.Eta()-leadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	    evLepVarR2.push_back(lepVar);
	    histocontainer_["h_lepVarRegion2"]->Fill(lepVar);
	  }
	  histocontainer_["h_pfCandidateBBOrtProjection"]->Fill(pfCandidateBBOrtProjection.Mag());
	  histocontainer_["h_pfCandidateBBProjection"]->Fill(pfCandidateBBProjection);
	  histocontainer_["h_pfCandidateBBOrtPercentProjection"]->Fill(pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection);
	  histocontainer_["h_pfCandidateBBPercentProjection"]->Fill(pfCandidateBBProjection/totalpfcBBProjection);
	  histocontainer_["h_pfCandidateDRjet"]->Fill( getDeltaR( pfc_vect, leadingJet) );
	  histocontainer_["h_nOfpfcLeadingJet"]->Fill(patLeadingJetPFCandidate.size());
	}
	histocontainer_["h_pfCandidateBBProjectionSum"]->Fill(pfCandidateBBProjectionSum);
	histocontainer_["h_pfCandidateBBOrtProjectionSum"]->Fill(pfCandidateBBOrtProjectionSum);
// 	pfCandidateBBOrtProjectionSum = 0;
// 	pfCandidateBBProjectionSum = 0;
// 	totalpfcBBOrtProjection = 0;
// 	totalpfcBBProjection = 0;
// 	for(size_t idx = 0; idx < patSecondLeadingJetPFCandidate.size(); idx++){
// 	  pfc_vect.SetXYZ(patSecondLeadingJetPFCandidate.at(idx)->px(),patSecondLeadingJetPFCandidate.at(idx)->py(),patSecondLeadingJetPFCandidate.at(idx)->pz());
// 	  pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir2.Unit());
// 	  pfCandidateBBProjection = pfc_vect.Dot(BBdir2.Unit());
// 	  totalpfcBBProjection += TMath::Abs(pfCandidateBBProjection);
// 	  totalpfcBBOrtProjection += pfCandidateBBOrtProjection.Mag();
// 	} 
      }
      else{

	// REGION 1 (between leadingJet and secondLeadingJet)
	std::vector<double> phiRegion1 = getPhiRatio(leadingJet, secondLeadingJet);
	// REGION 3 (between leadingJet and its closest beamline)
	std::vector<double> phiRegion3 = getPhiRatio(secondLeadingJet);

	pfCandidateBBOrtProjectionSum = 0;
	pfCandidateBBProjectionSum = 0;
	totalpfcBBOrtProjection = 0;
	totalpfcBBProjection = 0;
	for(size_t idx = 0; idx < patSecondLeadingJetPFCandidate.size(); idx++){
	  pfc_vect.SetXYZ(patSecondLeadingJetPFCandidate.at(idx)->px(),patSecondLeadingJetPFCandidate.at(idx)->py(),patSecondLeadingJetPFCandidate.at(idx)->pz());
	  pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir2.Unit());
	  pfCandidateBBProjection = pfc_vect.Dot(BBdir2.Unit());
	  totalpfcBBProjection += TMath::Abs(pfCandidateBBProjection);
	  totalpfcBBOrtProjection += pfCandidateBBOrtProjection.Mag();
	}
	//loop su tutti i pf candidate del secondLeading jet
	patSecondLeadingJetPFCandidate = secondLeadingJet->getPFConstituents();
	for(size_t idx = 0; idx < patSecondLeadingJetPFCandidate.size(); idx++){
	  pfc_vect.SetXYZ(patSecondLeadingJetPFCandidate.at(idx)->px(),patSecondLeadingJetPFCandidate.at(idx)->py(),patSecondLeadingJetPFCandidate.at(idx)->pz());
	  pfCandidateBBOrtProjection = pfc_vect.Cross(BBdir2.Unit());
	  pfCandidateBBProjection = pfc_vect.Dot(BBdir2.Unit());
	  pfCandidateBBOrtProjectionSum += pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection; 
	  pfCandidateBBProjectionSum += pfCandidateBBProjection/totalpfcBBProjection; 
	  // LEP var region 1
	  if( ( pfc_vect.Eta() < leadingJet->p4().Eta() and 
		pfc_vect.Eta() > secondLeadingJet->p4().Eta() ) or
	      ( pfc_vect.Eta() < secondLeadingJet->p4().Eta() and
		pfc_vect.Eta() > leadingJet->p4().Eta() ) ){
	    lepVar = TMath::Abs(pfc_vect.Eta()-secondLeadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	    evLepVarR1.push_back(lepVar);
	    histocontainer_["h_lepVarRegion1"]->Fill(lepVar);
	  }
	  // LEP var region 2 (between the beamline and the jet)
	  if( TMath::Abs(pfc_vect.Eta()) > TMath::Abs(secondLeadingJet->p4().Eta()) ){
	    lepVar = TMath::Abs(pfc_vect.Eta()-secondLeadingJet->p4().Eta()) / TMath::Abs(getDeltaEta(leadingJet, secondLeadingJet));
	    evLepVarR2.push_back(lepVar);
	    histocontainer_["h_lepVarRegion2"]->Fill(lepVar);
	  }
	  histocontainer_["h_pfCandidateBBOrtProjection"]->Fill(pfCandidateBBOrtProjection.Mag());
	  histocontainer_["h_pfCandidateBBProjection"]->Fill(pfCandidateBBProjection);
	  histocontainer_["h_pfCandidateBBOrtPercentProjection"]->Fill(pfCandidateBBOrtProjection.Mag()/totalpfcBBOrtProjection);
	  histocontainer_["h_pfCandidateBBPercentProjection"]->Fill(pfCandidateBBProjection/totalpfcBBProjection);
	  histocontainer_["h_pfCandidateDRjet"]->Fill( getDeltaR( pfc_vect, secondLeadingJet) );
	  histocontainer_["h_nOfpfcSecondLeadingJet"]->Fill(patSecondLeadingJetPFCandidate.size());
	}
	histocontainer_["h_pfCandidateBBOrtProjectionSum"]->Fill(pfCandidateBBOrtProjectionSum);
	histocontainer_["h_pfCandidateBBProjectionSum"]->Fill(pfCandidateBBProjectionSum);
	
      }

    }

    double evLepVar1 = 1e10;
    std::sort(evLepVarR1.begin(),evLepVarR1.end());
    for(unsigned int i = 0; i < evLepVarR1.size(); i++){
      evLepVar1 += evLepVarR1.at(i);
    }
    evLepVar1 /= evLepVarR1.size();
    double evLepVar2 = 1e10;
    std::sort(evLepVarR2.begin(),evLepVarR2.end());
    for(unsigned int i = 0; i < evLepVarR2.size(); i++){
      evLepVar2 += evLepVarR2.at(i);
    }
    evLepVar2 /= evLepVarR2.size();

    std::reverse(evLepVarR1.begin(), evLepVarR1.end());
    std::reverse(evLepVarR2.begin(), evLepVarR2.end());
    if(evLepVarR1.size() > 0 and evLepVarR2.size() > 0){
//       std::cout << "evLepVarR1 = " << evLepVarR1.at(0) << std::endl;
//       std::cout << "evLepVarR2 = " << evLepVarR1.at(1) << std::endl;
      
      histocontainer_["h_evLepVarR2"]->Fill(evLepVarR2.at(0));
      histocontainer_["h_evLepVarR1"]->Fill(getBBavProjection(leadingJet, secondLeadingJet));
      histocontainer_["h_evLepVarR1"]->Fill(getBBavProjection(secondLeadingJet, leadingJet));
    }

    // MY VAR
    myVar_background = getMyVar_background( &(bVertex_Jets_pair1.second) , bVertex_Jets_pair1.first.Vect() );
    myVar_signal = getMyVar_signal( &(bVertex_Jets_pair1.second) , bVertex_Jets_pair1.first.Vect(), BanglePhiEtaPlane );
//     std::cout << "Leading myVar_background = " << myVar_background << std::endl;
//     std::cout << "Leading myVar_signal = " << myVar_signal << std::endl;
    histocontainer_["h_myVar_background"]->Fill(myVar_background);
    histocontainer_["h_myVar_signal"]->Fill(myVar_signal);
    histocontainer_["h_myVar_ratio"]->Fill(myVar_signal/myVar_background);

    myVar_background = getMyVar_background( &(bVertex_Jets_pair2.second) , bVertex_Jets_pair2.first.Vect() );
    myVar_signal = getMyVar_signal( &(bVertex_Jets_pair2.second) , bVertex_Jets_pair2.first.Vect(), BanglePhiEtaPlane );
//     std::cout << "Leading myVar_background = " << myVar_background << std::endl;
//     std::cout << "Leading myVar_signal = " << myVar_signal << std::endl;
    histocontainer_["h_myVar_background"]->Fill(myVar_background);
    histocontainer_["h_myVar_signal"]->Fill(myVar_signal);
    histocontainer_["h_myVar_ratio"]->Fill(myVar_signal/myVar_background);

    // FILLING HISTOGRAMS
    histocontainer_2["h2_jetDeltaR_higgsCandidateMass"]->Fill(JetDeltaR, higgsCandidate.p4().M());
    histocontainer_2["h2_jetDeltaR_jetPtAsymmetry"]->Fill(JetDeltaR, jetPtAsymmetry );

    histocontainer_["h_jetDeltaPhiGeneral"]->Fill(jetDeltaPhi);
    histocontainer_["h_jetPtAsymmetryGeneral"]->Fill(jetPtAsymmetry);
    histocontainer_["h_deltaEtaBJetGeneral"]->Fill(deltaEta1General);
    histocontainer_["h_deltaEtaBJetGeneral"]->Fill(deltaEta2General);
    histocontainer_["h_jetDistancePerpendicularLineGeneral"]->Fill(jetDistancePerpendicularLineGeneral.at(0));
    histocontainer_["h_jetDistancePerpendicularLineGeneral"]->Fill(jetDistancePerpendicularLineGeneral.at(1));
    histocontainer_["h_alphaAngleGeneral"]->Fill(alphaAngle);
    histocontainer_["h_betaDistanceGeneral"]->Fill(betaDistance);
    histocontainer_["h_gammaDeltaRGeneral"]->Fill(gammaDeltaR);
    histocontainer_["h_epsilonDeltaEtaGeneral"]->Fill(epsilonDeltaEta);
    histocontainer_["h_digammaDeltaThetaGeneral"]->Fill(leadingDeltaTheta);
    histocontainer_["h_digammaDeltaThetaGeneral"]->Fill(secondLeadingDeltaTheta);
    histocontainer_3["h3_deltaR_ptB1_pt_B2_general"]->Fill(deltaR_general, ptb_general.at(0) , ptb_general.at(1));
    histocontainer_["h_jetDeltaR_general"]->Fill(JetDeltaR);
    histocontainer_["h_deltaR_general"]->Fill(deltaR_general);
    histocontainer_["h_jetDeltaEtaGeneral"]->Fill(JetDeltaEta);
    histocontainer_["h_invmass_general"]->Fill(invmass_general);
    histocontainer_["h_invmassJet_general"]->Fill(higgsCandidate.p4().M());
    histocontainer_["h_radiationEta"]->Fill(radiation1.Eta());
    histocontainer_["h_radiationEta"]->Fill(radiation2.Eta());
    histocontainer_["h_radiationBBProjection"]->Fill(radiation1BBProjection);
    histocontainer_["h_radiationBBProjection"]->Fill(radiation2BBProjection);
    histocontainer_["h_radiationBBOrtProjection"]->Fill(radiation1BBOrtProjection);
    histocontainer_["h_radiationBBOrtProjection"]->Fill(radiation2BBOrtProjection);
    histocontainer_["h_radiationBBOrtPercentProjection"]->Fill(radiation1BBOrtProjection/radiation1Energy);
    histocontainer_["h_radiationBBOrtPercentProjection"]->Fill(radiation2BBOrtProjection/radiation2Energy);
    histocontainer_["h_radiationBBPercentProjection"]->Fill(radiation1BBProjection/radiation1Energy);
    histocontainer_["h_radiationBBPercentProjection"]->Fill(radiation2BBProjection/radiation2Energy);

      
    histocontainer_2["h2_alphaAngle_invmassJet"]->Fill(alphaAngle, higgsCandidate.p4().M());
    histocontainer_2["h2_betaDistance_invmassJet"]->Fill(betaDistance, higgsCandidate.p4().M());
    histocontainer_2["h2_gammaDeltaR_invmassJet"]->Fill(gammaDeltaR, higgsCandidate.p4().M());
    histocontainer_2["h2_epsilonDeltaEta_invmassJet"]->Fill(epsilonDeltaEta, higgsCandidate.p4().M());
    histocontainer_2["h2_digammaDeltatheta_invmassJet"]->Fill(leadingDeltaTheta, higgsCandidate.p4().M());
    histocontainer_2["h2_JetDeltaEta_invmassJet"]->Fill(JetDeltaEta, higgsCandidate.p4().M());
    histocontainer_2["h2_JetDeltaR_invmassJet"]->Fill(JetDeltaR, higgsCandidate.p4().M());
    histocontainer_2["h2_JetDeltaPhi_invmassJet"]->Fill(jetDeltaPhi, higgsCandidate.p4().M());
    histocontainer_2["h2_jetPtAsymmetry_invmassJet"]->Fill(jetPtAsymmetry, higgsCandidate.p4().M());
    histocontainer_2["h2_deltaEtaBJet_invmassJet"]->Fill(deltaEta1General, higgsCandidate.p4().M());
    histocontainer_2["h2_deltaEtaBJet_invmassJet"]->Fill(deltaEta2General, higgsCandidate.p4().M());
    histocontainer_2["h2_jetDistancePerpendicularLine_invmassJet"]->Fill(jetDistancePerpendicularLineGeneral.at(0), higgsCandidate.p4().M());
    histocontainer_2["h2_jetDistancePerpendicularLine_invmassJet"]->Fill(jetDistancePerpendicularLineGeneral.at(1), higgsCandidate.p4().M());
    histocontainer_2["h2_deltaRGeneral_invmassJet"]->Fill(deltaR_general, higgsCandidate.p4().M());
    histocontainer_2["h2_jetDeltaEta_jetDeltaR"]->Fill(JetDeltaEta, JetDeltaR);
    
    
    if( bHadron_signal.size() > 1 ){ // Signal

      mypos1 = getAssociatedB( bHadron_signal, leadingJet );
      mypos2 = getAssociatedB( bHadron_signal, secondLeadingJet );
      std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair1_signal ( bHadron_signal.at(mypos1), *leadingJet );
      std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair2_signal ( bHadron_signal.at(mypos2), *secondLeadingJet );

      jetAnglePhiEtaPlane =  getAnglePhiEtaPlane( leadingJet, secondLeadingJet );
      BanglePhiEtaPlane = getAnglePhiEtaPlane( &(BhadronCollectionSignal[0]) , &(BhadronCollectionSignal[1]) );
      std::vector<double> jetDistancePerpendicularLineSignal;
      jetDistancePerpendicularLineSignal.push_back( TMath::Abs( leadingJet->p4().Phi() - leadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) ) ;
      jetDistancePerpendicularLineSignal.push_back( TMath::Abs( secondLeadingJet->p4().Phi() - secondLeadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) );
      alphaAngle = TMath::Abs( jetAnglePhiEtaPlane - BanglePhiEtaPlane ) ;
      if ( alphaAngle > 0.5*TMath::Pi() )
	alphaAngle = TMath::Abs( TMath::Abs( alphaAngle ) - TMath::Pi() ); // it takes the inclusive angle
      BdeltaR = getDeltaR( &(BhadronCollectionSignal[0]), &(BhadronCollectionSignal[1]) );
      JetDeltaR = getDeltaR( leadingJet, secondLeadingJet );
      betaDistance = BdeltaR - JetDeltaR;
      TLorentzVector p4sum_signal = bHadron_signal.at(0) + bHadron_signal.at(1);
      TLorentzVector TLV_Zcandidate;
      TLV_Zcandidate.SetXYZM( Zcandidate.p4().Px(), 
			      Zcandidate.p4().Py(),
			      Zcandidate.p4().Pz(),
			      Zcandidate.p4().M());
      histocontainer_["h_gen_HZ_deltaPhi"]->Fill( p4sum_signal.DeltaPhi( TLV_Zcandidate ) );
      TVector3 tmp1TV3, tmp2TV3;
      tmp1TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
      tmp2TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
      gammaDeltaR = 0.5 * ( p4sum.Vect().DeltaR( tmp1TV3 ) + p4sum.Vect().DeltaR( tmp2TV3 ) ) ;
      BdeltaEta = TMath::Abs( getDeltaEta( &(BhadronCollectionSignal[0]), &(BhadronCollectionSignal[1]) ) );
      JetDeltaEta = TMath::Abs( getDeltaEta( leadingJet, secondLeadingJet ) );
      epsilonDeltaEta = BdeltaEta - JetDeltaEta;
      deltaR_signal =  bHadron_signal.at(0).DeltaR( bHadron_signal.at(1) );
      invmass_signal = p4sum_signal.M();
      histocontainer_2["h2_ptHiggs_deltaR_signal"]->Fill(higgs_pt, deltaR_signal);
      if( higgsCandidate_pt > 100 ){
	std::vector<double> ptb_signal;
	double deltaEta1Signal = TMath::Abs( bVertex_Jets_pair1_signal.first.Eta() - bVertex_Jets_pair1_signal.second.p4().Eta() ) ;
	double deltaEta2Signal = TMath::Abs( bVertex_Jets_pair2_signal.first.Eta() - bVertex_Jets_pair2_signal.second.p4().Eta() ) ;
	histocontainer_["h_deltaEtaBJetSignal"]->Fill(deltaEta1Signal);
	histocontainer_["h_deltaEtaBJetSignal"]->Fill(deltaEta2Signal);
	histocontainer_["h_alphaAngleSignal"]->Fill(alphaAngle);
	histocontainer_["h_jetDistancePerpendicularLineSignal"]->Fill(jetDistancePerpendicularLineSignal.at(0));
	histocontainer_["h_jetDistancePerpendicularLineSignal"]->Fill(jetDistancePerpendicularLineSignal.at(1));
	histocontainer_["h_betaDistanceSignal"]->Fill(betaDistance);
	histocontainer_["h_gammaDeltaRSignal"]->Fill(gammaDeltaR);
	histocontainer_["h_epsilonDeltaEtaSignal"]->Fill(epsilonDeltaEta);
	histocontainer_["h_digammaDeltaThetaSignal"]->Fill(leadingDeltaTheta);
	histocontainer_["h_digammaDeltaThetaSignal"]->Fill(secondLeadingDeltaTheta);
	ptb_signal.push_back( bHadron_signal.at(0).Pt() );
	ptb_signal.push_back( bHadron_signal.at(1).Pt() );
	std::sort(ptb_signal.begin(), ptb_signal.end());
	histocontainer_3["h3_deltaR_ptB1_pt_B2_signal"]->Fill(deltaR_signal, ptb_signal.at(0) , ptb_signal.at(1));
	histocontainer_["h_jetDeltaR_signal"]->Fill(JetDeltaR);
	histocontainer_["h_deltaR_signal"]->Fill(deltaR_signal);
	histocontainer_["h_jetDeltaEtaSignal"]->Fill(JetDeltaEta);
	histocontainer_["h_invmass_signal"]->Fill(invmass_signal);
	histocontainer_["h_invmassJet_signal"]->Fill(higgsCandidate.p4().M());
      }
    }
    if( bHadron_background.size() > 1 ){ // Background

      mypos1 = getAssociatedB( bHadron_background, leadingJet );
      mypos2 = getAssociatedB( bHadron_background, secondLeadingJet );
      std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair1_background ( bHadron_background.at(mypos1), *leadingJet );
      std::pair< TLorentzVector, pat::Jet > bVertex_Jets_pair2_background ( bHadron_background.at(mypos2), *secondLeadingJet );

      jetAnglePhiEtaPlane =  getAnglePhiEtaPlane( leadingJet, secondLeadingJet );
      BanglePhiEtaPlane = getAnglePhiEtaPlane( &(BhadronCollectionBackground[0]) , &(BhadronCollectionBackground[1]) );
      std::vector<double> jetDistancePerpendicularLineBackground;
      jetDistancePerpendicularLineBackground.push_back( TMath::Abs( leadingJet->p4().Phi() - leadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) ) ;
      jetDistancePerpendicularLineBackground.push_back( TMath::Abs( secondLeadingJet->p4().Phi() - secondLeadingJet->p4().Eta() - ( bHadron_general.at(0).Phi() - BanglePhiEtaPlane * bHadron_general.at(0).Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) ) );
      alphaAngle = TMath::Abs( jetAnglePhiEtaPlane - BanglePhiEtaPlane ) ;
      if ( alphaAngle > 0.5*TMath::Pi() )
	alphaAngle = TMath::Abs( TMath::Abs( alphaAngle ) - TMath::Pi() ); // it takes the inclusive angle
      BdeltaR = getDeltaR( &(BhadronCollectionBackground[0]), &(BhadronCollectionBackground[1]) );
      JetDeltaR = getDeltaR( leadingJet, secondLeadingJet );
      betaDistance = BdeltaR - JetDeltaR;
      TLorentzVector p4sum_background = bHadron_background.at(0) + bHadron_background.at(1);
      TVector3 tmp1TV3, tmp2TV3;
      tmp1TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
      tmp2TV3.SetPtEtaPhi( leadingJet->p4().Pt(), leadingJet->p4().Eta(), leadingJet->p4().Phi() );
      gammaDeltaR = 0.5 * ( p4sum.Vect().DeltaR( tmp1TV3 ) + p4sum.Vect().DeltaR( tmp2TV3 ) ) ;
      BdeltaEta = TMath::Abs( getDeltaEta( &(BhadronCollectionBackground[0]), &(BhadronCollectionBackground[1]) ) );
      JetDeltaEta = TMath::Abs( getDeltaEta( leadingJet, secondLeadingJet ) );
      epsilonDeltaEta = BdeltaEta - JetDeltaEta;
      deltaR_background =  bHadron_background.at(0).DeltaR( bHadron_background.at(1) );
      invmass_background = p4sum_background.M();
      histocontainer_2["h2_ptVector_deltaR_background"]->Fill(vector_pt, deltaR_background);
      if( vector_pt > 100 ){
	double deltaEta1Background = TMath::Abs( bVertex_Jets_pair1_background.first.Eta() - bVertex_Jets_pair1_background.second.p4().Eta() ) ;
	double deltaEta2Background = TMath::Abs( bVertex_Jets_pair2_background.first.Eta() - bVertex_Jets_pair2_background.second.p4().Eta() ) ;
	histocontainer_["h_deltaEtaBJetBackground"]->Fill(deltaEta1Background);
	histocontainer_["h_deltaEtaBJetBackground"]->Fill(deltaEta2Background);
	histocontainer_["h_alphaAngleBackground"]->Fill(alphaAngle);
	histocontainer_["h_jetDistancePerpendicularLineBackground"]->Fill(jetDistancePerpendicularLineBackground.at(0));
	histocontainer_["h_jetDistancePerpendicularLineBackground"]->Fill(jetDistancePerpendicularLineBackground.at(1));
	histocontainer_["h_betaDistanceBackground"]->Fill(betaDistance);
	histocontainer_["h_gammaDeltaRBackground"]->Fill(gammaDeltaR);
	histocontainer_["h_epsilonDeltaEtaBackground"]->Fill(epsilonDeltaEta);
	histocontainer_["h_digammaDeltaThetaBackground"]->Fill(leadingDeltaTheta);
	histocontainer_["h_digammaDeltaThetaBackground"]->Fill(secondLeadingDeltaTheta);
	std::vector<double> ptb_background;
	ptb_background.push_back( bHadron_background.at(0).Pt() );
	ptb_background.push_back( bHadron_background.at(1).Pt() );
	std::sort(ptb_background.begin(), ptb_background.end());
	histocontainer_3["h3_deltaR_ptB1_pt_B2_background"]->Fill(deltaR_background, ptb_background.at(0) , ptb_background.at(1));
	histocontainer_["h_jetDeltaR_background"]->Fill(JetDeltaR);
	histocontainer_["h_deltaR_background"]->Fill(deltaR_background);
	histocontainer_["h_jetDeltaEtaBackground"]->Fill(JetDeltaEta);
	histocontainer_["h_invmass_background"]->Fill(invmass_background);
	histocontainer_2["h2_motherId_background"]->Fill(v_motherId.at(0), v_motherId.at(1));
	histocontainer_["h_invmassJet_background"]->Fill(higgsCandidate.p4().M());
      }
    }

  }


  v_akt5pfj.clear();

  
}//END EVENT LOOP

//funzione segno
inline int ZH_channel::getSign(double v) { return v > 0 ? 1 : (v < 0 ? -1 : 0); } 

//puliamo i pfjet dai muoni con un deltaR
// if it is true get rid of the jet
bool ZH_channel::muonJetCleaning(const pat::Jet& tmpJet, const std::vector<reco::Muon>& muCol, double deltaRcut){
  bool clean = false;
  double deltaR = 1e10;
  for(size_t muIdx = 0; muIdx < muCol.size(); ++muIdx){
    deltaR = Geom::deltaR(tmpJet.p4().Vect(), muCol.at(muIdx).p4().Vect() );
    if( deltaR < deltaRcut )
      clean = true;
  }  
  return clean;
}


//metodo per guardare se ha un Higgs come antenato
bool ZH_channel::hasHiggsMother( const reco::Candidate * particle ){
  bool hashiggsmother = false;
  while ( particle->numberOfMothers() != 0 ){
    if( particle->mother()->pdgId() == 25 )
      hashiggsmother = true;
    particle = particle->mother();
  }
  return hashiggsmother;
}

//check if there are dbflavoured daughters
bool ZH_channel::hasBdaughters( const reco::Candidate * particle ){
  bool myDaughterHasBottom = false;
  for(size_t myDau = 0; myDau < particle->numberOfDaughters(); myDau++){
    HepPDT::ParticleID myDaughter( particle->daughter(myDau)->pdgId() ); 
    myDaughterHasBottom += myDaughter.hasBottom();
  }
  return myDaughterHasBottom;
}

// calcolo dell'angolo nel piano eta phi della retta conguingente due jet
double ZH_channel::getAnglePhiEtaPlane( const pat::Jet *leadingJet , const pat::Jet *secondLeadingJet ){
  double angle = 1e10;
  double deltaPhi = leadingJet->p4().Phi() - secondLeadingJet->p4().Phi();
  double deltaEta = leadingJet->p4().Eta() - secondLeadingJet->p4().Eta();
  angle = TMath::ATan2( deltaPhi, deltaEta );
  return angle;
}

// calcolo dell'angolo nel piano eta phi della retta conguingente due b hadron
double ZH_channel::getAnglePhiEtaPlane( const reco::Candidate *firstB , const reco::Candidate *secondB ){
  double angle = 1e10;
  double deltaPhi = firstB->phi() - secondB->phi();
  double deltaEta = firstB->eta() - secondB->eta();
  angle = TMath::ATan2( deltaPhi, deltaEta );
  return angle;
}

double ZH_channel::getDeltaR( const pat::Jet * leadingJet, const pat::Jet * secondLeadingJet ){
  double deltaR = 1e10;
  deltaR = Geom::deltaR( leadingJet->p4().Vect(), secondLeadingJet->p4().Vect() );
  return deltaR;
}

double ZH_channel::getDeltaR( const reco::Candidate * firstB, const reco::Candidate * secondB ){
  double deltaR = 1e10;
  deltaR = Geom::deltaR( firstB->momentum(), secondB->momentum() );
  return deltaR;
}

double ZH_channel::getDeltaR( TLorentzVector TLV, const pat::Jet * patJet ){
  double deltaR = 1e10;
  TVector3 JetVector;
  JetVector.SetXYZ( patJet->p4().Px(), patJet->p4().Py(), patJet->p4().Pz() );
  deltaR = JetVector.DeltaR( TLV.Vect() ) ;
  return deltaR;
}

double ZH_channel::getDeltaR( TVector3 TLV, const pat::Jet * patJet ){
  double deltaR = 1e10;
  TVector3 JetVector;
  JetVector.SetXYZ( patJet->p4().Px(), patJet->p4().Py(), patJet->p4().Pz() );
  deltaR = JetVector.DeltaR( TLV ) ;
  return deltaR;
}

double ZH_channel::getDeltaEta( const pat::Jet * leadingJet, const pat::Jet * secondLeadingJet ){
  double deltaEta = 1e10;
  deltaEta = leadingJet->p4().Eta() - secondLeadingJet->p4().Eta() ;
  return deltaEta;
}

double ZH_channel::getDeltaEta( const reco::Candidate * firstB, const reco::Candidate * secondB ){
  double deltaEta = 1e10;
  deltaEta = firstB->eta() - secondB->eta() ;
  return deltaEta;
}

double ZH_channel::getDeltaPhi( const pat::Jet* leadingJet, const pat::Jet* secondLeadingJet){

  double deltaPhi = 1e10;
  deltaPhi = Geom::deltaPhi( leadingJet->p4().Vect(), secondLeadingJet->p4().Vect() ) ;
  return deltaPhi;

}

double ZH_channel::getPtAsymmetry(const pat::Jet* leadingJet, const pat::Jet* secondLeadingJet ){

  double asymmetry = 1e10;
  double ptDiff = leadingJet->p4().Pt() - secondLeadingJet->p4().Pt();
  double ptSum = leadingJet->p4().Pt() + secondLeadingJet->p4().Pt();
  asymmetry = ptDiff / ptSum;
  return asymmetry;
}

unsigned int ZH_channel::getAssociatedB( std::vector<TLorentzVector> bHadron_vector, const pat::Jet* leadingJet){

  //association Bvertex - Jet
  double deltaMin = 1e10;
  unsigned int mypos = 1e2;
  for( size_t b = 0; b < bHadron_vector.size(); ++b){
    TVector3 leadingJetVector;
    leadingJetVector.SetXYZ( leadingJet->p4().Px(), leadingJet->p4().Py(), leadingJet->p4().Pz() );
    if( leadingJetVector.DeltaR( bHadron_vector.at(b).Vect() )  < deltaMin ){
      deltaMin = leadingJetVector.DeltaR( bHadron_vector.at(b).Vect() ) ;
      mypos = b;
    }
  }
  return mypos;
}


double ZH_channel::getBBavProjection( const pat::Jet* j1, const pat::Jet* j2 ){

  TVector2 ci;
  TVector2 r;
  TVector2 v_j1( j1->p4().Eta(), j1->p4().Phi());
  TVector2 v_j2( j2->p4().Eta(), j2->p4().Phi());
  TVector2 bb = v_j2 - v_j1;
  TVector2 bbdir = bb.Unit();
  double proj = 0;
  double totProj = 1e10;
  
  std::vector<reco::PFCandidatePtr>
    patJetpfc = j1->getPFConstituents();
  for(size_t idx = 0; idx < patJetpfc.size(); idx++){
    ci.Set( patJetpfc.at(idx)->eta(), patJetpfc.at(idx)->phi() );
    r  = ci - v_j1;
    totProj += (r.Proj(bbdir)).Mod();
  }
  
  for(size_t idx = 0; idx < patJetpfc.size(); idx++){
    ci.Set( patJetpfc.at(idx)->eta(), patJetpfc.at(idx)->phi() );
    r  = ci - v_j1;
    proj += (r.X()*bbdir.X()+r.Y()*bbdir.Y())/totProj;
  }
  
  return proj;
  
}


// FIXED variabile consigliata nell'articolo teorico sulla color reconnection
TVector2 ZH_channel::getTvect( const pat::Jet* patJet, TLorentzVector b ){

  TVector2 t_Vect;
  TVector2 ci;
  TVector2 J;
  TVector2 r;
  TVector2 v_b( b.Eta(), b.Phi());
  double patJetpfcPt = 1e10;
  double r_mag = 1e10;

  std::vector<reco::PFCandidatePtr>
    patJetpfc = patJet->getPFConstituents();
  for(size_t idx = 0; idx < patJetpfc.size(); idx++){
    patJetpfcPt = patJetpfc.at(idx)->pt();
    ci.Set( patJetpfc.at(idx)->eta(), patJetpfc.at(idx)->phi() );
    J.Set( patJet->p4().Eta(), patJet->p4().Phi() );
    //    r  = ci - J;
    r  = ci - v_b;
    r_mag = r.Mod();
    t_Vect += ( (patJetpfcPt * r_mag) / patJet->p4().Pt() ) * r;
  }

  return t_Vect;
  
}

double ZH_channel::getDeltaTheta( const pat::Jet* j1, const pat::Jet* j2, TLorentzVector b1, TLorentzVector b2 ){

  double deltaTheta = 1e10;
  TVector2 v_j1(j1->p4().Eta(), j1->p4().Phi());
  TVector2 v_j2(j2->p4().Eta(), j2->p4().Phi());
  TVector2 v_b1(b1.Eta(), b1.Phi());
  TVector2 v_b2(b2.Eta(), b2.Phi());

  TVector2 t = getTvect(j1, b1);

  deltaTheta = Geom::deltaPhi(t.Phi(), v_b2.Phi());

  return deltaTheta;

}

double ZH_channel::getDeltaX( const pat::Jet* j1, const pat::Jet* j2, TLorentzVector b1, TLorentzVector b2 ){

  double deltaX = 1e10;
  TVector2 v_j1(j1->p4().Eta(), j1->p4().Phi());
  TVector2 v_j2(j2->p4().Eta(), j2->p4().Phi());
  TVector2 v_b1(b1.Eta(), b1.Phi());
  TVector2 v_b2(b2.Eta(), b2.Phi());

  TVector2 t = getTvect(j1, b1);

  deltaX = t.X() - v_b2.X();

  return deltaX;

}

double ZH_channel::getDeltaY( const pat::Jet* j1, const pat::Jet* j2, TLorentzVector b1, TLorentzVector b2 ){

  double deltaY = 1e10;
  TVector2 v_j1(j1->p4().Eta(), j1->p4().Phi());
  TVector2 v_j2(j2->p4().Eta(), j2->p4().Phi());
  TVector2 v_b1(b1.Eta(), b1.Phi());
  TVector2 v_b2(b2.Eta(), b2.Phi());

  TVector2 t = getTvect(j1, b1);

  deltaY = t.Y() - v_b2.Y();

  return deltaY;

}

double ZH_channel::getMyVar_background( const pat::Jet* patJet, TVector3 Bpos ){

  TVector3 t_vect;
  double patJetTrackPt = 1e10;
  double deltaEta = 1e10;
  double myvar =  0;
  reco::TrackRefVector patJetTrack;

  //loop su tutte le tracce del jet
  patJetTrack = patJet->associatedTracks();
  for(size_t idx = 0; idx < patJetTrack.size(); idx++){
    patJetTrackPt = patJetTrack.at(idx)->pt();
    t_vect.SetXYZ(patJetTrack.at(idx)->px(),patJetTrack.at(idx)->py(),patJetTrack.at(idx)->pz());
    deltaEta = TMath::Abs( t_vect.Eta() - Bpos.Eta() );
    myvar += deltaEta / patJetTrackPt; 
  }
  return myvar;
}

double ZH_channel::getMyVar_signal( const pat::Jet* patJet, TVector3 Bpos, double BanglePhiEtaPlane ){

  TVector3 t_vect;
  double patJetTrackPt = 1e10;
  double distPL = 1e10;
  double myvar =  0;
  double jetPhi = 1e10;
  double jetEta = 1e10;
  reco::TrackRefVector patJetTrack;

  jetPhi = patJet->p4().Phi();
  jetEta = patJet->p4().Eta();

  //loop su tutte le tracce del jet
  patJetTrack = patJet->associatedTracks();
  for(size_t idx = 0; idx < patJetTrack.size(); idx++){
    patJetTrackPt = patJetTrack.at(idx)->pt();
    t_vect.SetXYZ(patJetTrack.at(idx)->px(),patJetTrack.at(idx)->py(),patJetTrack.at(idx)->pz());
    distPL =  TMath::Abs( jetPhi - jetEta - ( Bpos.Phi() - BanglePhiEtaPlane * Bpos.Eta() ) / TMath::Sqrt( 1 + TMath::Power(BanglePhiEtaPlane,2) ) );
    myvar += 1 / ( patJetTrackPt * distPL ); 
  }
  return myvar;
}


std::vector<double> ZH_channel::getPhiRatio( const pat::Jet* leadingJet, const pat::Jet* secondLeadingJet ){

  std::vector<double> phiRatio;
  TVector3 leadingJetVector;
  leadingJetVector.SetXYZ( leadingJet->p4().Px(), leadingJet->p4().Py(), leadingJet->p4().Pz() );
  TVector3 secondLeadingJetVector;
  secondLeadingJetVector.SetXYZ( secondLeadingJet->p4().Px(), secondLeadingJet->p4().Py(), secondLeadingJet->p4().Pz() );
  double jetAngle = leadingJetVector.Angle(secondLeadingJetVector);
  TVector3 pfc_vect;
  TVector3 p1;
  TVector3 p2;
  TVector3 p12;

  std::vector<reco::PFCandidatePtr>
    patLeadingJetPFCandidate = leadingJet->getPFConstituents();
  for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	p1 = ( pfc_vect.Dot(leadingJetVector.Unit()) * leadingJetVector);
	p2 = ( pfc_vect.Dot(secondLeadingJetVector.Unit()) * secondLeadingJetVector);
	p12 = p1 + p2;
	phiRatio.push_back( (p12.Angle(leadingJetVector) / jetAngle) );
  }

  return phiRatio;

}

std::vector<double> ZH_channel::getPhiRatio( const pat::Jet* patJet ){

  std::vector<double> phiRatio;
  TVector3 patJetVector;
  patJetVector.SetXYZ( patJet->p4().Px(), patJet->p4().Py(), patJet->p4().Pz() );
  TVector3 beamline;
  if( getSign( patJet->p4().Eta() ) > 0 )
    beamline.SetXYZ(0,0,1);
  else
    beamline.SetXYZ(0,0,-1);

  double jetAngle = patJetVector.Angle(beamline);
  TVector3 pfc_vect;
  TVector3 p1;
  TVector3 p2;
  TVector3 p12;

  std::vector<reco::PFCandidatePtr>
    patLeadingJetPFCandidate = patJet->getPFConstituents();
  for(size_t idx = 0; idx < patLeadingJetPFCandidate.size(); idx++){
	pfc_vect.SetXYZ(patLeadingJetPFCandidate.at(idx)->px(),patLeadingJetPFCandidate.at(idx)->py(),patLeadingJetPFCandidate.at(idx)->pz());
	p1 = ( pfc_vect.Dot(patJetVector.Unit()) * patJetVector);
	p2 = ( pfc_vect.Dot(beamline.Unit()) * beamline);
	p12 = p1 + p2;
	phiRatio.push_back( (p12.Angle(patJetVector) / jetAngle) );
  }

  return phiRatio;

}



void ZH_channel::beginJob()
{
  
  using namespace std;  
  edm::Service<TFileService> fs;

  Int_t bin_evLepVar = 500;
  Double_t min_evLepVar = 0;
  Double_t max_evLepVar = 50;

  histocontainer_["h_evLepVarR1"]=fs->make<TH1D>("h_evLepVarR1","evLepVar_region1", bin_evLepVar , min_evLepVar , max_evLepVar );
  histocontainer_["h_evLepVarR2"]=fs->make<TH1D>("h_evLepVarR2","evLepVar_region2", bin_evLepVar , min_evLepVar , max_evLepVar );

  Int_t bin_lepvar = 500;
  Double_t min_lepvar = 0;
  Double_t max_lepvar = 1;

  histocontainer_["h_lepVarRegion1"]=fs->make<TH1D>("h_lepVarRegion1","lepvar_region1", bin_lepvar , min_lepvar , max_lepvar );
  histocontainer_["h_lepVarRegion2"]=fs->make<TH1D>("h_lepVarRegion2","lepvar_region2", bin_lepvar , min_lepvar , max_lepvar );

  Int_t bin_cnt = 200;
  Double_t min_cnt = 0;
  Double_t max_cnt = 200;

  histocontainer_["h_nOfpfcLeadingJet"]=fs->make<TH1D>("h_nOfpfcLeadingJet","nOfpfcLeadingJet", bin_cnt , min_cnt , max_cnt );
  histocontainer_["h_nOfpfcSecondLeadingJet"]=fs->make<TH1D>("h_nOfpfcSecondLeadingJet","nOfpfcSecondLeadingJet", bin_cnt , min_cnt , max_cnt );

  Int_t bin_asymmetry = 200;
  Double_t min_asymmetry = -1;
  Double_t max_asymmetry = 1;

  histocontainer_["h_jetPtAsymmetryGeneral"]=fs->make<TH1D>("h_jetPtAsymmetryGeneral"," jet Pt Asymmetry", bin_asymmetry , min_asymmetry , max_asymmetry );
  histocontainer_["h_radiationBBOrtPercentProjection"]=fs->make<TH1D>("h_radiationBBOrtPercentProjection","h_radiationBBOrtPercentProjection", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_radiationBBPercentProjection"]=fs->make<TH1D>("h_radiationBBPercentProjection","h_radiationBBPercentProjection", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_trackBBPercentProjection"]=fs->make<TH1D>("h_trackBBPercentProjection","h_trackBBPercentProjection", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_pfCandidateBBOrtPercentProjection"]=fs->make<TH1D>("h_pfCandidateBBOrtPercentProjection","h_pfCandidateBBOrtPercentProjection", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_pfCandidateBBOrtProjectionSum"]=fs->make<TH1D>("h_pfCandidateBBOrtProjectionSum","h_pfCandidateBBOrtProjectionSum", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_pfCandidateBBPercentProjection"]=fs->make<TH1D>("h_pfCandidateBBPercentProjection","h_pfCandidateBBPercentProjection", bin_asymmetry, min_asymmetry, max_asymmetry);
  histocontainer_["h_pfCandidateBBProjectionSum"]=fs->make<TH1D>("h_pfCandidateBBProjectionSum","h_pfCandidateBBProjectionSum", bin_asymmetry, min_asymmetry, max_asymmetry);

  Int_t bin_angle = 300;
  Double_t min_angle = -6;
  Double_t max_angle = 6;
  
  histocontainer_["h_jetDeltaPhiGeneral"]=fs->make<TH1D>("h_jetDeltaPhiGeneral","h_jetDeltaPhi",bin_angle, min_angle, max_angle);

  histocontainer_["h_HZ_deltaPhi"]=fs->make<TH1D>("h_HZ_deltaPhi","h_HZ_deltaPhi",bin_angle, min_angle, max_angle);
  histocontainer_["h_gen_HZ_deltaPhi"]=fs->make<TH1D>("h_gen_HZ_deltaPhi","h_gen_HZ_deltaPhi",bin_angle, min_angle, max_angle);

  histocontainer_["h_alphaAngleSignal"]=fs->make<TH1D>("h_alphaAngleSignal","h_alphaAngleSignal", bin_angle, min_angle, max_angle);
  histocontainer_["h_alphaAngleBackground"]=fs->make<TH1D>("h_alphaAngleBackground","h_alphaAngleBackground", bin_angle, min_angle, max_angle);
  histocontainer_["h_alphaAngleGeneral"]=fs->make<TH1D>("h_alphaAngleGeneral","h_alphaAngleGeneral", bin_angle, min_angle, max_angle);

  histocontainer_["h_digammaDeltaThetaSignal"]=fs->make<TH1D>("h_digammaDeltaThetaSignal","h_digammaDeltaThetaSignal", bin_angle, min_angle, max_angle);
  histocontainer_["h_digammaDeltaThetaBackground"]=fs->make<TH1D>("h_digammaDeltaThetaBackground","h_digammaDeltaThetaBackground", bin_angle, min_angle, max_angle);
  histocontainer_["h_digammaDeltaThetaGeneral"]=fs->make<TH1D>("h_digammaDeltaThetaGeneral","h_digammaDeltaThetaGeneral", bin_angle, min_angle, max_angle);


  Int_t bin_eta = 600;
  Double_t min_eta = -3;
  Double_t max_eta = 3;

  histocontainer_["h_goodJetEta"]=fs->make<TH1D>("h_goodJetEta","h_goodJetEta",bin_eta, min_eta, max_eta);
  histocontainer_["h_badJetEta"]=fs->make<TH1D>("h_badJetEta","h_badJetEta",bin_eta, min_eta, max_eta);

  histocontainer_["h_epsilonDeltaEtaSignal"]=fs->make<TH1D>("h_epsilonDeltaEtaSignal","deltaEta signal (H)", bin_eta, min_eta, max_eta);
  histocontainer_["h_epsilonDeltaEtaBackground"]=fs->make<TH1D>("h_epsilonDeltaEtaBackground","deltaEta background", bin_eta, min_eta, max_eta);
  histocontainer_["h_epsilonDeltaEtaGeneral"]=fs->make<TH1D>("h_epsilonDeltaEtaGeneral","deltaEta general", bin_eta, min_eta, max_eta);

  histocontainer_["h_epsilonDeltaEtaSmartGeneral"]=fs->make<TH1D>("h_epsilonDeltaEtaSmartGeneral","deltaEtaSmart general", bin_eta, min_eta, max_eta);

  histocontainer_["h_deltaEtaBJetGeneral"]=fs->make<TH1D>("h_deltaEtaBJetGeneral","h_deltaEtaBJetGeneral", bin_eta, min_eta, max_eta);
  histocontainer_["h_deltaEtaBJetSignal"]=fs->make<TH1D>("h_deltaEtaBJetSignal","h_deltaEtaBJetSignal", bin_eta, min_eta, max_eta);
  histocontainer_["h_deltaEtaBJetBackground"]=fs->make<TH1D>("h_deltaEtaBJetBackground","h_deltaEtaBJetBackground", bin_eta, min_eta, max_eta);

  histocontainer_["h_jetDeltaEtaGeneral"]=fs->make<TH1D>("h_jetDeltaEtaGeneral","h_jetDeltaEtaGeneral", bin_eta, min_eta, max_eta);
  histocontainer_["h_jetDeltaEtaSignal"]=fs->make<TH1D>("h_jetDeltaEtaSignal","h_jetDeltaEtaSignal", bin_eta, min_eta, max_eta);
  histocontainer_["h_jetDeltaEtaBackground"]=fs->make<TH1D>("h_jetDeltaEtaBackground","h_jetDeltaEtaBackground", bin_eta, min_eta, max_eta);

  histocontainer_["h_jetDeltaEtaSmartGeneral"]=fs->make<TH1D>("h_jetDeltaEtaSmartGeneral","h_jetDeltaEtaSmartGeneral", bin_eta, min_eta, max_eta);

  histocontainer_["h_radiationEta"]=fs->make<TH1D>("h_radiationEta","h_radiationEta", bin_eta, min_eta, max_eta);


  //Bool histo

  histocontainer_["h_H_dau_hasBottom"]=fs->make<TH1D>("h_H_dau_hasBottom","h_H_dau_hasBottom",2,0,1);

  Int_t bin_pt = 50;
  Double_t min_pt = 0;
  Double_t max_pt = 500;

  histocontainer_["h_goodJetPt"]=fs->make<TH1D>("h_goodJetPt","h_goodJetPt",bin_pt, min_pt, max_pt);
  histocontainer_["h_badJetPt"]=fs->make<TH1D>("h_badJetPt","h_badJetPt",bin_pt, min_pt, max_pt);

  histocontainer_["h_higgsCandidate_pt"]=fs->make<TH1D>("h_higgsCandidate_pt","p_{t} of H candidate [GeV/c]", bin_pt, min_pt, max_pt);
  histocontainer_["h_Zcandidate_pt"]=fs->make<TH1D>("h_Zcandidate_pt","h_Zcandidate_pt",bin_pt, min_pt, max_pt);
  histocontainer_["h_Z_pt"]=fs->make<TH1D>("h_Z_pt","p_{t} of Z [GeV/c]", bin_pt, min_pt, max_pt);
  histocontainer_["h_W_pt"]=fs->make<TH1D>("h_W_pt","p_{t} of W [GeV/c]", bin_pt, min_pt, max_pt);
  histocontainer_["h_H_pt"]=fs->make<TH1D>("h_H_pt","p_{t} of H [GeV/c]", bin_pt, min_pt, max_pt);

  
  Int_t bin_pdgId = 2000;
  Double_t min_pdgId = -1000;
  Double_t max_pdgId = 1000;

  histocontainer_["h_pdgId"]=fs->make<TH1D>("h_pdgId","pdgID", bin_pdgId, min_pdgId, max_pdgId);
  histocontainer_["h_H_dau_pdgId"]=fs->make<TH1D>("h_H_dau_pdgId","h_H_dau_pdgId", bin_pdgId, min_pdgId, max_pdgId);
  histocontainer_2["h2_pdgId_status"]=fs->make<TH2D>("h2_pdgId_status","pdgID vs status", bin_pdgId, min_pdgId, max_pdgId, 20 , -10 , 10);
  histocontainer_2["h2_pdgId_particleID"]=fs->make<TH2D>("h2_pdgId_particleID","pdgID vs particleID", bin_pdgId, min_pdgId, max_pdgId, bin_pdgId, min_pdgId, max_pdgId );
  histocontainer_2["h2_motherId_background"]=fs->make<TH2D>("h2_motherId_background","pdgID", bin_pdgId, min_pdgId, max_pdgId, bin_pdgId, min_pdgId, max_pdgId);

  Int_t bin_deltaR = 600;
  Double_t min_deltaR = 0;
  Double_t max_deltaR = 10;

  histocontainer_["h_deltaR_signal"]=fs->make<TH1D>("h_deltaR_signal","deltaR signal (H)", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_deltaR_background"]=fs->make<TH1D>("h_deltaR_background","deltaR background", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_deltaR_general"]=fs->make<TH1D>("h_deltaR_general","deltaR general", bin_deltaR, min_deltaR, max_deltaR);

  histocontainer_["h_jetDeltaR_signal"]=fs->make<TH1D>("h_jetDeltaR_signal","jetDeltaR signal (H)", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_jetDeltaR_background"]=fs->make<TH1D>("h_jetDeltaR_background","jetDeltaR background", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_jetDeltaR_general"]=fs->make<TH1D>("h_jetDeltaR_general","jetDeltaR general", bin_deltaR, min_deltaR, max_deltaR);

  histocontainer_["h_gammaDeltaRSignal"]=fs->make<TH1D>("h_gammaDeltaRSignal","deltaR signal (H)", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_gammaDeltaRBackground"]=fs->make<TH1D>("h_gammaDeltaRBackground","deltaR background", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_gammaDeltaRGeneral"]=fs->make<TH1D>("h_gammaDeltaRGeneral","deltaR general", bin_deltaR, min_deltaR, max_deltaR);

  histocontainer_["h_jetDistancePerpendicularLineGeneral"]=fs->make<TH1D>("h_jetDistancePerpendicularLineGeneral","h_jetDistancePerpendicularLineGeneral",bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_jetDistancePerpendicularLineSignal"]=fs->make<TH1D>("h_jetDistancePerpendicularLineSignal","h_jetDistancePerpendicularLineSignal",bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_jetDistancePerpendicularLineBackground"]=fs->make<TH1D>("h_jetDistancePerpendicularLineBackground","h_jetDistancePerpendicularLineBackground",bin_deltaR, min_deltaR, max_deltaR);

  histocontainer_["h_pfCandidateDRjet"]=fs->make<TH1D>("h_pfCandidateDRjet","deltaR pfc jet", bin_deltaR, min_deltaR, max_deltaR);

  bin_deltaR = 600;
  min_deltaR = -5;
  max_deltaR = 5;

  histocontainer_["h_betaDistanceSignal"]=fs->make<TH1D>("h_betaDistanceSignal","deltaR signal (H)", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_betaDistanceBackground"]=fs->make<TH1D>("h_betaDistanceBackground","deltaR background", bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_["h_betaDistanceGeneral"]=fs->make<TH1D>("h_betaDistanceGeneral","deltaR general", bin_deltaR, min_deltaR, max_deltaR);

  //redefinition of the binning on pt
  bin_pt=1000;
  min_pt=-100;
  max_pt=100;

  histocontainer_["h_radiationBBOrtProjection"]=fs->make<TH1D>("h_radiationBBOrtProjection","h_radiationBBOrtProjection", bin_pt, min_pt, max_pt);
  histocontainer_["h_radiationBBProjection"]=fs->make<TH1D>("h_radiationBBProjection","h_radiationBBProjection", bin_pt, min_pt, max_pt);
  histocontainer_["h_radiationEtaProjection"]=fs->make<TH1D>("h_radiationEtaProjection","h_radiationEtaProjection", bin_pt, min_pt, max_pt);
  histocontainer_["h_trackBBProjection"]=fs->make<TH1D>("h_trackBBProjection","h_trackBBProjection", bin_pt, min_pt, max_pt);
  histocontainer_["h_pfCandidateBBOrtProjection"]=fs->make<TH1D>("h_pfCandidateBBOrtProjection","h_pfCandidateBBOrtProjection", bin_pt, min_pt, max_pt);
  histocontainer_["h_pfCandidateBBProjection"]=fs->make<TH1D>("h_pfCandidateBBProjection","h_pfCandidateBBProjection", bin_pt, min_pt, max_pt);

  //redefine the binning on pt
  bin_pt=100;
  min_pt=0;
  max_pt=500;

  histocontainer_2["h2_ptHiggs_deltaR_signal"]=fs->make<TH2D>("h2_ptHiggs_deltaR_signal","h2_ptHiggs_deltaR_signal",
							      bin_pt, min_pt, max_pt,
							      bin_deltaR, min_deltaR, max_deltaR);
  histocontainer_2["h2_ptVector_deltaR_background"]=fs->make<TH2D>("h2_ptVector_deltaR_background","h2_ptVector_deltaR_background",
								   bin_pt, min_pt, max_pt,
								   bin_deltaR, min_deltaR, max_deltaR);

  histocontainer_3["h3_deltaR_ptB1_pt_B2_general"]=fs->make<TH3D>("h3_deltaR_ptB1_pt_B2_general",
								 "h3_deltaR_ptB1_pt_B2_general",
								 bin_deltaR, min_deltaR, max_deltaR,
								 bin_pt, min_pt, max_pt,
								 bin_pt, min_pt, max_pt);
  histocontainer_3["h3_deltaR_ptB1_pt_B2_signal"]=fs->make<TH3D>("h3_deltaR_ptB1_pt_B2_signal",
								 "h3_deltaR_ptB1_pt_B2_signal",
								 bin_deltaR, min_deltaR, max_deltaR,
								 bin_pt, min_pt, max_pt,
								 bin_pt, min_pt, max_pt);
  histocontainer_3["h3_deltaR_ptB1_pt_B2_background"]=fs->make<TH3D>("h3_deltaR_ptB1_pt_B2_background",
								     "h3_deltaR_ptB1_pt_B2_background",
								     bin_deltaR, min_deltaR, max_deltaR,
								     bin_pt, min_pt, max_pt,
								     bin_pt, min_pt, max_pt);  

  Int_t bin_invmass = 600;
  Double_t min_invmass = 0;
  Double_t max_invmass = 200;

  histocontainer_["h_Zcandidate_mass"]=fs->make<TH1D>("h_Zcandidate_mass","h_Zcandidate_mass", bin_invmass, min_invmass, max_invmass);
  histocontainer_["h_higgsCandidate_mass"]=fs->make<TH1D>("h_higgsCandidate_mass","h_higgsCandidate_mass", bin_invmass, min_invmass, max_invmass);

  histocontainer_["h_invmassJet_signal"]=fs->make<TH1D>("h_invmassJet_signal","invmassJet signal (H)", bin_invmass, min_invmass, max_invmass);
  histocontainer_["h_invmassJet_background"]=fs->make<TH1D>("h_invmassJet_background","invmassJet background", bin_invmass, min_invmass, max_invmass);
  histocontainer_["h_invmassJet_general"]=fs->make<TH1D>("h_invmassJet_general","invmassJet general", bin_invmass, min_invmass, max_invmass);

  histocontainer_["h_invmass_signal"]=fs->make<TH1D>("h_invmass_signal","invmass signal (H)", bin_invmass, min_invmass, max_invmass);
  histocontainer_["h_invmass_background"]=fs->make<TH1D>("h_invmass_background","invmass background", bin_invmass, min_invmass, max_invmass);
  histocontainer_["h_invmass_general"]=fs->make<TH1D>("h_invmass_general","invmass general", bin_invmass, min_invmass, max_invmass);


  histocontainer_2["h2_jetDeltaR_higgsCandidateMass"]=fs->make<TH2D>("h2_jetDeltaR_higgsCandidateMass",
								     "jetDeltaR vs higgs Mass", 
								     bin_deltaR, min_deltaR, max_deltaR, 
								     bin_invmass, min_invmass, max_invmass );
  histocontainer_2["h2_jetDeltaR_jetPtAsymmetry"]=fs->make<TH2D>("h2_jetDeltaR_jetPtAsymmetry",
								 "jetDeltaR vs jet Asymmetry", 
								 bin_deltaR, min_deltaR, max_deltaR, 
								 bin_asymmetry, min_asymmetry, max_asymmetry );


  Int_t bin_myVar = 400;
  Double_t min_myVar = 0;
  Double_t max_myVar = 400;

  histocontainer_["h_myVar_background"]=fs->make<TH1D>("h_myVar_background","h_myVar_background", bin_myVar, min_myVar, max_myVar);
  histocontainer_["h_myVar_signal"]=fs->make<TH1D>("h_myVar_signal","h_myVar_signal", bin_myVar, min_myVar, max_myVar);
  histocontainer_["h_myVar_ratio"]=fs->make<TH1D>("h_myVar_ratio","h_myVar_ratio", bin_myVar, min_myVar, max_myVar);



  histocontainer_2["h2_alphaAngle_invmassJet"]=fs->make<TH2D>("h2_alphaAngle_invmassJet","h2_alphaAngle_invmassJet",bin_angle, min_angle, max_angle, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_betaDistance_invmassJet"]=fs->make<TH2D>("h2_betaDistance_invmassJet","h2_betaDistance_invmassJet", bin_deltaR, min_deltaR, max_deltaR, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_gammaDeltaR_invmassJet"]=fs->make<TH2D>("h2_gammaDeltaR_invmassJet","h2_gammaDeltaR_invmassJet",bin_deltaR, min_deltaR, max_deltaR, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_epsilonDeltaEta_invmassJet"]=fs->make<TH2D>("h2_epsilonDeltaEta_invmassJet","h2_epsilonDeltaEta_invmassJet",bin_eta, min_eta, max_eta, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_digammaDeltatheta_invmassJet"]=fs->make<TH2D>("h2_digammaDeltatheta_invmassJet","h2_digammaDeltatheta_invmassJet", bin_angle, min_angle, max_angle, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_JetDeltaEta_invmassJet"]=fs->make<TH2D>("h2_JetDeltaEta_invmassJet","h2_JetDeltaEta_invmassJet", bin_eta, min_eta, max_eta, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_JetDeltaR_invmassJet"]=fs->make<TH2D>("h2_JetDeltaR_invmassJet","h2_JetDeltaR_invmassJet", bin_deltaR, min_deltaR, max_deltaR, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_JetDeltaPhi_invmassJet"]=fs->make<TH2D>("h2_JetDeltaPhi_invmassJet","h2_JetDeltaPhi_invmassJet",bin_angle, min_angle, max_angle, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_jetPtAsymmetry_invmassJet"]=fs->make<TH2D>("h2_jetPtAsymmetry_invmassJet","h2_jetPtAsymmetry_invmassJet", bin_asymmetry, min_asymmetry, max_asymmetry, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_deltaEtaBJet_invmassJet"]=fs->make<TH2D>("h2_deltaEtaBJet_invmassJet","h2_deltaEtaBJet_invmassJet", bin_eta, min_eta, max_eta, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_jetDistancePerpendicularLine_invmassJet"]=fs->make<TH2D>("h2_jetDistancePerpendicularLine_invmassJet","h2_jetDistancePerpendicularLine_invmassJet", bin_deltaR, min_deltaR, max_deltaR, bin_invmass, min_invmass, max_invmass);
  histocontainer_2["h2_deltaRGeneral_invmassJet"]=fs->make<TH2D>("h2_deltaRGeneral_invmassJet","h2_deltaRGeneral_invmassJet",bin_eta, min_eta, max_eta, bin_invmass, min_invmass, max_invmass);

  histocontainer_2["h2_jetDeltaEta_jetDeltaR"]=fs->make<TH2D>("h2_jetDeltaEta_jetDeltaR","h2_jetDeltaEta_jetDeltaR",bin_eta, min_eta, max_eta, bin_deltaR, min_deltaR, max_deltaR);
  

  histocontainer_2["h2_deltaX_deltaY"]=fs->make<TH2D>("h2_deltaX_deltaY","h2_deltaX_deltaY",bin_eta, min_eta, max_eta, bin_angle, min_angle, max_angle);

}

void ZH_channel::endJob() {

  std::cout << "Number of events with at least two B hadrons = " << myEvents << std::endl;
  std::cout << "JOB FINISHED" << std::endl;

}

DEFINE_FWK_MODULE(ZH_channel);
